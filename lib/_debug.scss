@use 'sass:list';
@use 'sass:map';
@use 'vendor/@nirazul/scss-utils/lib/function/list/purge' as *;
@use 'vendor/@nirazul/scss-utils/lib/mixin/hide-visually' as *;
@use 'vendor/@nirazul/scss-utils/lib/mixin/at-root' as *;
@use 'vendor/sass-to-js/sass/sass-to-js' as *;
@use 'index' as lib;

/// Convert a map of media expressions into a list of all possible viewport combinations
/// @param {Map} $expressions - Map of media feature expressions, grouped by type
/// @return {Map} - Conjugated map of all possible media feature expressions
///
@function conditions($expressions) {
  $result: ((),);

  @each $list-key, $list-value in $expressions {
    $combinations: ();
    $list-value: map.merge((null: null), $list-value);

    @each $item-key, $item-value in $list-value {
      @each $combination in $result {
        $combinations: list.append($combinations, map.merge($combination, ($list-key: $item-key)));
      }
    }

    $result: $combinations;
  }

  @return $result;
}

/// Convert a list of media expressions into a list of sass maps with name and query properties
/// @param {Map} $expressions - A flat list of media feature expressions
/// @return {List} - A list of maps containing all available separate media queries used in the project
///
@function expressions($expressions) {
  $result: ();

  @each $type, $conditions in $expressions {
    @each $name, $value in $conditions {
      $result: list.append($result, (name: $name, query: $value, type: $type));
    }
  }

  @return $result;
}

/// Write the viewport information into a content attribute, contained by the media expression it describes
/// @param {string} $root-class - Class that serves as root name for the elements containing the mq data
///
@mixin write($root-class) {
  // Type
  @each $type-key, $type-value in $media-type-expressions {
    #{$root-class}-type::before {
      @include lib.mq($type-value) {
        content: sassToJs($type-value);
      }
    }
  }

  // Conditions
  @each $conditions in conditions($media-feature-expressions) {
    $media-conditions: purge(map.values($conditions));

    #{$root-class}-conditions::before {
      @include lib.mq($media-conditions...) {
        content: sassToJs($conditions);
      }
    }
  }

  // Expressions
  $expressions-list: expressions(map.merge((type: $media-type-expressions), $media-feature-expressions));

  #{$root-class}-expressions::before {
    content: sassToJs($expressions-list);
  }
}

/// Add a hidden but readable hook to be used in html and js
/// @param {string} $root-class - Class that serves as root name for the elements containing the mq data
///
@mixin display($root-class) {
  @include write($root-class);

  #{$root-class}-type::before,
  #{$root-class}-conditions::before,
  #{$root-class}-expressions::before {
    @include hide-visually;
  }

  #{$root-class}-conditions {
    @include at-root(html, '.u-mq-info') {
      &::before {
        pointer-events: none;
        z-index: 9999;

        position: fixed;
        bottom: 0;
        left: 0;

        display: block;
        width: auto;
        height: auto;
        max-width: 50%;
        max-height: none;
        padding: 15px;
        margin: 0;

        clip: auto;
        font-family: monospace;
        font-size: 12px;
        line-height: 1.1;
        word-wrap: break-word;
        color: #ffffff;
        background-color: rgba(22, 25, 40, 0.9);
        border-top-right-radius: 5px;
        text-align: left;
      }

      &::before {
        transition: visibility 0ms ease 2000ms;
        visibility: hidden;
      }
    }
  }
}
